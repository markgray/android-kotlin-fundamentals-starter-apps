/*
 * Copyright 2019, The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@file:Suppress("DEPRECATION")

package com.example.android.trackmysleepquality.sleeptracker

import android.app.Application
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import androidx.databinding.DataBindingUtil
import androidx.fragment.app.Fragment
import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.Observer
import androidx.lifecycle.ViewModelProviders
import androidx.navigation.fragment.findNavController
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.example.android.trackmysleepquality.R
import com.example.android.trackmysleepquality.database.SleepDatabase
import com.example.android.trackmysleepquality.database.SleepDatabaseDao
import com.example.android.trackmysleepquality.database.SleepNight
import com.example.android.trackmysleepquality.databinding.FragmentSleepTrackerBinding
import com.google.android.material.snackbar.Snackbar

/**
 * A fragment with buttons to record start and end times for sleep, which are saved in
 * a database. Cumulative data is displayed in a `RecyclerView`.
 *
 * The Clear button will clear all data from the database.
 */
class SleepTrackerFragment : Fragment() {

    /**
     * Called when the Fragment is ready to display content to the screen. This function uses
     * DataBindingUtil to inflate our layout file R.layout.fragment_sleep_quality. It is also
     * responsible for passing the [SleepTrackerViewModel] to the [FragmentSleepTrackerBinding]
     * generated by DataBinding. This will allow DataBinding to use the `LiveData` on our ViewModel.
     * We start by initializing our [FragmentSleepTrackerBinding] variable `val binding` to the
     * binding returned by using the [DataBindingUtil.inflate] method to inflate our layout file
     * R.layout.fragment_sleep_tracker, and our [Application] variable `val application` to the
     * application that owns this activity. We initialize our [SleepDatabaseDao] variable
     * `val dataSource` to the `Room` handle to our database (creating it if need be). We initialize
     * our [SleepTrackerViewModelFactory] variable `val viewModelFactory` to an instance which will
     * use `dataSource` and `application` when it creates a [SleepTrackerViewModel], and then use
     * it to initialize our [SleepTrackerViewModel] variable `val sleepTrackerViewModel` to an
     * existing ViewModel or a new one if need be in the scope of *this* fragment, then set the
     * `sleepTrackerViewModel` property of `binding` to `sleepTrackerViewModel` (this is a variable
     * element of a data element in the layout file fragment_sleep_tracker.xml). We initialize our
     * [SleepNightAdapter] variable `val adapter` to a new instance whose [SleepNightListener]
     * argument is a lambda which will call the `onSleepNightClicked` method of `sleepTrackerViewModel`
     * with the `nightId` PrimaryKey of the [SleepNight] in the [RecyclerView] whose ICON was clicked
     * (this sets the `_navigateToSleepDetail` [MutableLiveData] property to the `nightId` and an
     * observer will cause the app to navigate to the `SleepDetailFragment` to display the details
     * of that [SleepNight]). We then set the `adapter` of the android:id="@+id/sleep_list"
     * [RecyclerView] to `adapter`.
     *
     * We add an [Observer] to the `LiveData` property `nights` of `sleepTrackerViewModel` whose
     * lambda receives from this LiveData and if *it* is not *null* calls the `addHeaderAndSubmitList`
     * method of `adapter` with *it* as the [List] of [SleepNight] to display.
     *
     * We set the `lifecycleOwner` prpoperty of `binding` to *this* [LifecycleOwner] (necessary so
     * that the binding can observe LiveData updates).
     *
     * We add an [Observer] to the `LiveData` property `showSnackBarEvent` of `sleepTrackerViewModel`
     * whose lambda receives the [Boolean] from this `LiveData` and if *it* is *true* shows a
     * [Snackbar] message advising the user that all his data is gone (`showSnackBarEvent` is set to
     * *true* by the "Clear" button in our layout file by a call to `sleepTrackerViewModel.onClear()`
     * when it is clicked).
     *
     * We add an [Observer] to the `LiveData` property `navigateToSleepQuality` of `sleepTrackerViewModel`
     * whose lambda receives the [SleepNight] we are currently editing (the "Start" button was clicked)
     * and if it is not *null* navigates to the `SleepQualityFragment` with the `nightId` PrimaryKey
     * of the "tonight" [SleepNight] being edited, then calls the `doneNavigating` method of
     * `sleepTrackerViewModel` to reset the state of `navigateToSleepQuality` so that we only navigate
     * once, even if the device has a configuration change.
     *
     * We add an [Observer] to the `LiveData` property `navigateToSleepDetail` of `sleepTrackerViewModel`
     * whose lambda receives the `nightId` of the [SleepNight] whose item in the `GridView` was clicked
     * and if it is not *null* navigates to the `SleepDetailFragment` with that `nightId` PrimaryKey,
     * then calls the `onSleepDetailNavigated` method of `sleepTrackerViewModel` to set the state of
     * value of  `navigateToSleepDetail` to *null* so that we only navigate once, even if the device
     * has a configuration change.
     *
     * We initialize our [GridLayoutManager] variable `val manager` to an instance with a column count
     * of 3, then set its `spanSizeLookup` property to an anonymous *object* whose `getSpanSize`
     * override returns 3 columns if the adapter position of the item is 0, or 1 for all other items.
     * We then set the `layoutManager` property of the android:id="@+id/sleep_list" [RecyclerView]
     * in our layout file `binding` to `manager`.
     *
     * Finally we return the outermost View in the layout file associated with `binding` to the caller.
     *
     * @param inflater The LayoutInflater object that can be used to inflate
     * any views in the fragment,
     * @param container If non-null, this is the parent view that the fragment's
     * UI should be attached to.  The fragment should not add the view itself,
     * but this can be used to generate the LayoutParams of the view.
     * @param savedInstanceState If non-null, this fragment is being re-constructed
     * from a previous saved state as given here.
     * @return Return the View for the fragment's UI, or null.
     */
    @Suppress("RedundantNullableReturnType")
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?,
                              savedInstanceState: Bundle?): View? {

        // Get a reference to the binding object and inflate the fragment views.
        val binding: FragmentSleepTrackerBinding = DataBindingUtil.inflate(
                inflater, R.layout.fragment_sleep_tracker, container, false)

        val application: Application = requireNotNull(this.activity).application

        // Create an instance of the ViewModel Factory.
        val dataSource: SleepDatabaseDao = SleepDatabase.getInstance(application).sleepDatabaseDao
        val viewModelFactory = SleepTrackerViewModelFactory(dataSource, application)

        // Get a reference to the ViewModel associated with this fragment.
        val sleepTrackerViewModel= ViewModelProviders.of(
                        this,
                        viewModelFactory
                ).get(SleepTrackerViewModel::class.java)

        // To use the View Model with data binding, you have to explicitly
        // give the binding object a reference to it.
        binding.sleepTrackerViewModel = sleepTrackerViewModel

        val adapter = SleepNightAdapter(SleepNightListener { nightId ->
            //Toast.makeText(context, "${nightId}", Toast.LENGTH_LONG).show()
            sleepTrackerViewModel.onSleepNightClicked(nightId)
        })
        binding.sleepList.adapter = adapter

        sleepTrackerViewModel.nights.observe(viewLifecycleOwner) {
            it?.let {
                adapter.addHeaderAndSubmitList(it)
            }
        }

        // Specify the current activity as the lifecycle owner of the binding.
        // This is necessary so that the binding can observe LiveData updates.
        binding.lifecycleOwner = this

        // Add an Observer on the state variable for showing a Snackbar message
        // when the CLEAR button is pressed.
        sleepTrackerViewModel.showSnackBarEvent.observe(viewLifecycleOwner) {
            if (it == true) { // Observed state is true.
                Snackbar.make(
                    requireActivity().findViewById(android.R.id.content),
                    getString(R.string.cleared_message),
                    Snackbar.LENGTH_SHORT // How long to display the message.
                ).show()
                // Reset state to make sure the Snackbar is only shown once, even if the device
                // has a configuration change.
                sleepTrackerViewModel.doneShowingSnackbar()
            }
        }

        // Add an Observer on the state variable for Navigating when STOP button is pressed.
        sleepTrackerViewModel.navigateToSleepQuality.observe(viewLifecycleOwner) { night ->
            night?.let {
                // We need to get the navController from this, because button is not ready, and it
                // just has to be a view. For some reason, this only matters if we hit stop again
                // after using the back button, not if we hit stop and choose a quality.
                // Also, in the Navigation Editor, for Quality -> Tracker, check "Inclusive" for
                // popping the stack to get the correct behavior if we press stop multiple times
                // followed by back.
                // Also: https://stackoverflow.com/questions/28929637/difference-and-uses-of-oncreate-oncreateview-and-onactivitycreated-in-fra
                this.findNavController().navigate(
                    SleepTrackerFragmentDirections
                        .actionSleepTrackerFragmentToSleepQualityFragment(night.nightId)
                )
                // Reset state to make sure we only navigate once, even if the device
                // has a configuration change.
                sleepTrackerViewModel.doneNavigating()
            }
        }

        // Add an Observer on the state variable for Navigating when an item is clicked.
        sleepTrackerViewModel.navigateToSleepDetail.observe(viewLifecycleOwner) { night ->
            night?.let {

                this.findNavController().navigate(
                    SleepTrackerFragmentDirections
                        .actionSleepTrackerFragmentToSleepDetailFragment(night)
                )
                sleepTrackerViewModel.onSleepDetailNavigated()
            }
        }

        val manager = GridLayoutManager(activity, 3)
        manager.spanSizeLookup = object : GridLayoutManager.SpanSizeLookup() {
            /**
             * Returns the number of span occupied by the item at `position`.
             *
             * @param position The adapter position of the item
             * @return The number of spans occupied by the item at the provided position
             */
            override fun getSpanSize(position: Int) =  when (position) {
                0 -> 3
                else -> 1
            }
        }
        binding.sleepList.layoutManager = manager

        return binding.root
    }
}
